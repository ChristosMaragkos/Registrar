<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Registrar/Base/Registry.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Registrar/Base/Registry.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;&#10;namespace Registrar.Base&#10;{&#10;    /// &lt;summary&gt;&#10;    /// I made this class for the sole purpose of having a non-generic entry point&#10;    /// for the static Register method, so you don't have to specify the type parameter T&#10;    /// when calling Register.&#10;    /// Is it petty? Yes. Do I care? Not really.&#10;    /// It just makes the API a bit cleaner to use, and brings it closer to Minecraft's&#10;    /// &lt;c&gt;Registry.register(Registry.BLOCK, id, block)&lt;/c&gt; style.&#10;    /// &lt;para&gt;&lt;/para&gt;&#10;    /// ...which is probably not a good thing to aspire to,&#10;    /// both because Minecraft was written in another language&#10;    /// and because Minecraft's code reads like a Unabomber manifesto.&#10;    /// &lt;/summary&gt;&#10;    public static class Registry&#10;    {&#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, Identifier identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, identifier, content);&#10;        }&#10;        &#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, string identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, Identifier.TryParse(identifier), content);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Abstract base class for registries that map unique identifiers to content of type T.&#10;    /// Supports registration by &lt;see cref=&quot;Identifier&quot;/&gt; as well as retrieval by &lt;see cref=&quot;Identifier&quot;/&gt; &#10;    /// or raw numerical ID. Implements &lt;see cref=&quot;IEnumerable{T}&quot;/&gt;&#10;    /// to allow enumeration of stored entries.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type of content this Registry&#10;    /// instance stores. Must be a reference type.&lt;/typeparam&gt;&#10;    public abstract class Registry&lt;T&gt; : IEnumerable&lt;T&gt; where T : class&#10;    {&#10;        private readonly object _lock = new object();&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Tracks the next available raw numerical ID for registration.&#10;        /// &lt;/summary&gt;&#10;        private int _nextRawId;&#10;&#10;        /// &lt;summary&gt;&#10;        /// Maps &lt;see cref=&quot;Identifier&quot;/&gt; keys to their corresponding content.&#10;        /// &lt;/summary&gt;&#10;        private readonly Dictionary&lt;Identifier, T&gt; _entriesByIdentifier &#10;            = new Dictionary&lt;Identifier, T&gt;();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Maps raw numerical IDs to their corresponding content.&#10;        /// &lt;/summary&gt;&#10;        private readonly Dictionary&lt;int, T&gt; _entriesByRawId &#10;            = new Dictionary&lt;int, T&gt;();&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Registers a new entry in the registry with the specified identifier and content.&#10;        /// If the identifier already exists, the existing content is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;registry&quot;&gt;The registry instance where the entry will be registered.&lt;/param&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The unique identifier for the content.&lt;/param&gt;&#10;        /// &lt;param name=&quot;content&quot;&gt;The content to register.&lt;/param&gt;&#10;        /// &lt;returns&gt;The registered content, either newly added or already existing.&lt;/returns&gt;&#10;        protected internal static T Register(Registry&lt;T&gt; registry, Identifier identifier, T content)&#10;        {&#10;            lock (registry._lock)&#10;            {&#10;                if (registry._entriesByIdentifier.TryGetValue(identifier, &#10;                        out var registeredValue)) return registeredValue;&#10;&#10;                registry._entriesByIdentifier[identifier] = content;&#10;                registry._entriesByRawId[registry._nextRawId] = content;&#10;                registry._nextRawId++;&#10;                return content;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its identifier (thread-safe).&#10;        /// If the identifier is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the identifier, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? Get(Identifier identifier)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.TryGetValue(identifier, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its raw numerical ID (thread-safe).&#10;        /// If the raw ID is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the raw ID, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? GetByRawId(int rawId)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.TryGetValue(rawId, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified identifier.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the identifier exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsId(Identifier identifier)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.ContainsKey(identifier);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified raw numerical ID.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the raw ID exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsRawId(int rawId)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.ContainsKey(rawId);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the identifier associated with the specified content.&#10;        /// If the content is not found, the fallback identifier is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The identifier associated with the content, or the fallback&#10;        /// identifier if not found.&lt;/returns&gt;&#10;        public Identifier? GetId(T value)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return !_entriesByIdentifier.ContainsValue(value)&#10;                    ? GetIdentifierOnFail()&#10;                    : _entriesByIdentifier.First(kv =&gt; kv.Value == value).Key;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the raw numerical ID associated with the specified content.&#10;        /// If the content is not found, the fallback raw ID is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The raw numerical ID associated with the content, or the fallback&#10;        /// raw ID if not found.&lt;/returns&gt;&#10;        public int? GetRawId(T value)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return !_entriesByRawId.ContainsValue(value)&#10;                    ? GetRawIdOnFail()&#10;                    : _entriesByRawId.First(kv =&gt; kv.Value == value).Key;&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Fetches a random entry from the registry.&#10;        /// Uses the provided Random instance to select an entry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;random&quot;&gt;The &lt;see cref=&quot;Random&quot;/&gt; to derive the index from.&lt;/param&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        public T GetRandom(Random random)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                if (_entriesByRawId.Count == 0)&#10;                    throw new InvalidOperationException(&quot;Cannot retrieve a random entry from an empty registry.&quot;);&#10;                return _entriesByRawId[random.Next(_entriesByRawId.Count)];&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the total number of registered entries (thread-safe).&#10;        /// &lt;/summary&gt;&#10;        public int Count&#10;        {&#10;            get { lock (_lock) return _entriesByIdentifier.Count; }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts the registry's entries to a list of content.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;A list of all content stored in the registry.&lt;/returns&gt;&#10;        public List&lt;T&gt; ToList()&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.Values.ToList();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        public IEnumerator&lt;T&gt; GetEnumerator()&#10;        {&#10;            // snapshot to allow safe enumeration without holding lock during iteration&#10;            List&lt;T&gt; snapshot;&#10;            lock (_lock)&#10;            {&#10;                snapshot = _entriesByIdentifier.Values.ToList();&#10;            }&#10;            return snapshot.GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        IEnumerator IEnumerable.GetEnumerator()&#10;        {&#10;            return GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback value when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback value.&lt;/returns&gt;&#10;        protected abstract T? GetValueOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback identifier when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback identifier.&lt;/returns&gt;&#10;        protected abstract Identifier? GetIdentifierOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback raw numerical ID when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback raw numerical ID.&lt;/returns&gt;&#10;        protected abstract int? GetRawIdOnFail();&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;&#10;namespace Registrar.Base&#10;{&#10;    /// &lt;summary&gt;&#10;    /// I made this class for the sole purpose of having a non-generic entry point&#10;    /// for the static Register method, so you don't have to specify the type parameter T&#10;    /// when calling Register.&#10;    /// Is it petty? Yes. Do I care? Not really.&#10;    /// It just makes the API a bit cleaner to use, and brings it closer to Minecraft's&#10;    /// &lt;c&gt;Registry.register(Registry.BLOCK, id, block)&lt;/c&gt; style.&#10;    /// &lt;para&gt;&lt;/para&gt;&#10;    /// ...which is probably not a good thing to aspire to,&#10;    /// both because Minecraft was written in another language&#10;    /// and because Minecraft's code reads like a Unabomber manifesto.&#10;    /// &lt;/summary&gt;&#10;    public static class Registry&#10;    {&#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, Identifier identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, identifier, content);&#10;        }&#10;        &#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, string identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, Identifier.TryParse(identifier), content);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Abstract base class for registries that map unique identifiers to content of type T.&#10;    /// Supports registration by &lt;see cref=&quot;Identifier&quot;/&gt; as well as retrieval by &lt;see cref=&quot;Identifier&quot;/&gt; &#10;    /// or raw numerical ID. Implements &lt;see cref=&quot;IEnumerable{T}&quot;/&gt;&#10;    /// to allow enumeration of stored entries.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type of content this Registry&#10;    /// instance stores. Must be a reference type.&lt;/typeparam&gt;&#10;    public abstract class Registry&lt;T&gt; : IEnumerable&lt;T&gt; where T : class&#10;    {&#10;        private readonly object _lock = new object();&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Tracks the next available raw numerical ID for registration.&#10;        /// &lt;/summary&gt;&#10;        private int _nextRawId;&#10;&#10;        /// &lt;summary&gt;&#10;        /// Maps &lt;see cref=&quot;Identifier&quot;/&gt; keys to their corresponding content.&#10;        /// &lt;/summary&gt;&#10;        private readonly Dictionary&lt;Identifier, T&gt; _entriesByIdentifier &#10;            = new Dictionary&lt;Identifier, T&gt;();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Maps raw numerical IDs to their corresponding content.&#10;        /// &lt;/summary&gt;&#10;        private readonly Dictionary&lt;int, T&gt; _entriesByRawId &#10;            = new Dictionary&lt;int, T&gt;();&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Registers a new entry in the registry with the specified identifier and content.&#10;        /// If the identifier already exists, the existing content is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;registry&quot;&gt;The registry instance where the entry will be registered.&lt;/param&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The unique identifier for the content.&lt;/param&gt;&#10;        /// &lt;param name=&quot;content&quot;&gt;The content to register.&lt;/param&gt;&#10;        /// &lt;returns&gt;The registered content, either newly added or already existing.&lt;/returns&gt;&#10;        protected internal static T Register(Registry&lt;T&gt; registry, Identifier identifier, T content)&#10;        {&#10;            lock (registry._lock)&#10;            {&#10;                if (registry._entriesByIdentifier.TryGetValue(identifier, &#10;                        out var registeredValue)) return registeredValue;&#10;&#10;                registry._entriesByIdentifier[identifier] = content;&#10;                registry._entriesByRawId[registry._nextRawId] = content;&#10;                registry._nextRawId++;&#10;                return content;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its identifier (thread-safe).&#10;        /// If the identifier is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the identifier, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? Get(Identifier identifier)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.TryGetValue(identifier, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its raw numerical ID (thread-safe).&#10;        /// If the raw ID is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the raw ID, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? GetByRawId(int rawId)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.TryGetValue(rawId, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified identifier.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the identifier exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsId(Identifier identifier)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.ContainsKey(identifier);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified raw numerical ID.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the raw ID exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsRawId(int rawId)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.ContainsKey(rawId);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the identifier associated with the specified content.&#10;        /// If the content is not found, the fallback identifier is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The identifier associated with the content, or the fallback&#10;        /// identifier if not found.&lt;/returns&gt;&#10;        public Identifier? GetId(T value)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return !_entriesByIdentifier.ContainsValue(value)&#10;                    ? GetIdentifierOnFail()&#10;                    : _entriesByIdentifier.First(kv =&gt; kv.Value == value).Key;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the raw numerical ID associated with the specified content.&#10;        /// If the content is not found, the fallback raw ID is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The raw numerical ID associated with the content, or the fallback&#10;        /// raw ID if not found.&lt;/returns&gt;&#10;        public int? GetRawId(T value)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return !_entriesByRawId.ContainsValue(value)&#10;                    ? GetRawIdOnFail()&#10;                    : _entriesByRawId.First(kv =&gt; kv.Value == value).Key;&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Fetches a random entry from the registry.&#10;        /// Uses the provided Random instance to select an entry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;random&quot;&gt;The &lt;see cref=&quot;Random&quot;/&gt; to derive the index from.&lt;/param&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        public T GetRandom(Random random)&#10;        {&#10;            lock (_lock)&#10;            {&#10;                if (_entriesByRawId.Count == 0)&#10;                    throw new InvalidOperationException(&quot;Cannot retrieve a random entry from an empty registry.&quot;);&#10;                return _entriesByRawId[random.Next(_entriesByRawId.Count)];&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the total number of registered entries (thread-safe).&#10;        /// &lt;/summary&gt;&#10;        public int Count&#10;        {&#10;            get { lock (_lock) return _entriesByIdentifier.Count; }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts the registry's entries to a list of content.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;A list of all content stored in the registry.&lt;/returns&gt;&#10;        public List&lt;T&gt; ToList()&#10;        {&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.Values.ToList();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        public IEnumerator&lt;T&gt; GetEnumerator()&#10;        {&#10;            // snapshot to allow safe enumeration without holding lock during iteration&#10;            List&lt;T&gt; snapshot;&#10;            lock (_lock)&#10;            {&#10;                snapshot = _entriesByIdentifier.Values.ToList();&#10;            }&#10;            return snapshot.GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        IEnumerator IEnumerable.GetEnumerator()&#10;        {&#10;            return GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback value when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback value.&lt;/returns&gt;&#10;        protected abstract T? GetValueOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback identifier when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback identifier.&lt;/returns&gt;&#10;        protected abstract Identifier? GetIdentifierOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback raw numerical ID when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback raw numerical ID.&lt;/returns&gt;&#10;        protected abstract int? GetRawIdOnFail();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>