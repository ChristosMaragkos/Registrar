<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Registrar/Base/Registry.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Registrar/Base/Registry.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;&#10;namespace Registrar.Base&#10;{&#10;    /// &lt;summary&gt;&#10;    /// I made this class for the sole purpose of having a non-generic entry point&#10;    /// for the static Register method, so you don't have to specify the type parameter T&#10;    /// when calling Register.&#10;    /// Is it petty? Yes. Do I care? Not really.&#10;    /// It just makes the API a bit cleaner to use, and brings it closer to Minecraft's&#10;    /// &lt;c&gt;Registry.register(Registry.BLOCK, id, block)&lt;/c&gt; style.&#10;    /// &lt;para&gt;&lt;/para&gt;&#10;    /// ...which is probably not a good thing to aspire to,&#10;    /// both because Minecraft was written in another language&#10;    /// and because Minecraft's code reads like a Unabomber manifesto.&#10;    /// &lt;/summary&gt;&#10;    public static class Registry&#10;    {&#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, Identifier identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, identifier, content);&#10;        }&#10;        &#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, string identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, Identifier.Parse(identifier), content);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Abstract base class for registries that map unique identifiers to content of type T.&#10;    /// Supports registration by &lt;see cref=&quot;Identifier&quot;/&gt; as well as retrieval by &lt;see cref=&quot;Identifier&quot;/&gt; &#10;    /// or raw numerical ID. Implements &lt;see cref=&quot;IEnumerable{T}&quot;/&gt;&#10;    /// to allow enumeration of stored entries.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type of content this Registry&#10;    /// instance stores. Must be a reference type.&lt;/typeparam&gt;&#10;    public abstract class Registry&lt;T&gt; : IEnumerable&lt;T&gt;, IFreezableRegistry where T : class&#10;    {&#10;        private readonly object _lock = new object();&#10;        private int _nextRawId;&#10;        private readonly Dictionary&lt;Identifier, T&gt; _entriesByIdentifier = new Dictionary&lt;Identifier, T&gt;();&#10;        private readonly Dictionary&lt;int, T&gt; _entriesByRawId = new Dictionary&lt;int, T&gt;();&#10;        // New reverse lookup dictionaries&#10;        private readonly Dictionary&lt;T, Identifier&gt; _identifierByValue; // one-to-one enforced&#10;        private readonly Dictionary&lt;T, int&gt; _rawIdByValue;&#10;&#10;        private volatile bool _frozen;&#10;&#10;        public bool IsFrozen =&gt; _frozen;&#10;&#10;        protected Registry(IEqualityComparer&lt;T&gt;? comparer = null)&#10;        {&#10;            var valueComparer = comparer ?? EqualityComparer&lt;T&gt;.Default;&#10;            _identifierByValue = new Dictionary&lt;T, Identifier&gt;(valueComparer);&#10;            _rawIdByValue = new Dictionary&lt;T, int&gt;(valueComparer);&#10;        }&#10;        /// &lt;summary&gt;&#10;        /// Registers a new entry in the registry with the specified identifier and content.&#10;        /// If the identifier already exists, the existing content is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;registry&quot;&gt;The registry instance where the entry will be registered.&lt;/param&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The unique identifier for the content.&lt;/param&gt;&#10;        /// &lt;param name=&quot;content&quot;&gt;The content to register.&lt;/param&gt;&#10;        /// &lt;returns&gt;The registered content, either newly added or already existing.&lt;/returns&gt;&#10;        protected internal static T Register(Registry&lt;T&gt; registry, Identifier identifier, T content)&#10;        {&#10;            // Fast path: prevent entering lock if already frozen and known to reject&#10;            if (registry._frozen)&#10;                throw new InvalidOperationException(&quot;Registry is already frozen&quot;);&#10;            lock (registry._lock)&#10;            {&#10;                if (registry._frozen)&#10;                    throw new InvalidOperationException(&quot;Registry is already frozen&quot;);&#10;                if (registry._entriesByIdentifier.TryGetValue(identifier, out var registeredValue))&#10;                    return registeredValue; // id already present, return existing value&#10;                // Enforce uniqueness of value -&gt; identifier&#10;                if (registry._identifierByValue.TryGetValue(content, out var existingId))&#10;                {&#10;                    // If same identifier, treat as idempotent (shouldn't happen since earlier check). If different, throw.&#10;                    return !existingId.Equals(identifier) &#10;                        ? throw new InvalidOperationException($&quot;Value already registered under identifier '{existingId}'. Duplicate registration with '{identifier}' is not allowed.&quot;) : content;&#10;                }&#10;&#10;                var rawId = registry._nextRawId;&#10;                registry._nextRawId++;&#10;&#10;                registry._entriesByIdentifier[identifier] = content;&#10;                registry._entriesByRawId[rawId] = content;&#10;                registry._identifierByValue[content] = identifier;&#10;                registry._rawIdByValue[content] = rawId;&#10;                return content;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its identifier (thread-safe).&#10;        /// If the identifier is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the identifier, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? Get(Identifier identifier)&#10;        {&#10;            if (_frozen)&#10;                return _entriesByIdentifier.TryGetValue(identifier, out var v) ? v : GetValueOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.TryGetValue(identifier, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its raw numerical ID (thread-safe).&#10;        /// If the raw ID is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the raw ID, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? GetByRawId(int rawId)&#10;        {&#10;            if (_frozen)&#10;                return _entriesByRawId.TryGetValue(rawId, out var v) ? v : GetValueOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.TryGetValue(rawId, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified identifier.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the identifier exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsId(Identifier identifier)&#10;        {&#10;            if (_frozen) return _entriesByIdentifier.ContainsKey(identifier);&#10;            lock (_lock) { return _entriesByIdentifier.ContainsKey(identifier); }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified raw numerical ID.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the raw ID exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsRawId(int rawId)&#10;        {&#10;            if (_frozen) return _entriesByRawId.ContainsKey(rawId);&#10;            lock (_lock) { return _entriesByRawId.ContainsKey(rawId); }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the identifier associated with the specified content.&#10;        /// If the content is not found, the fallback identifier is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The identifier associated with the content, or the fallback&#10;        /// identifier if not found.&lt;/returns&gt;&#10;        public Identifier? GetId(T value)&#10;        {&#10;            if (_frozen)&#10;                return _identifierByValue.TryGetValue(value, out var id) ? id : GetIdentifierOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _identifierByValue.TryGetValue(value, out var id)&#10;                    ? id&#10;                    : GetIdentifierOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the raw numerical ID associated with the specified content.&#10;        /// If the content is not found, the fallback raw ID is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The raw numerical ID associated with the content, or the fallback&#10;        /// raw ID if not found.&lt;/returns&gt;&#10;        public int? GetRawId(T value)&#10;        {&#10;            if (_frozen)&#10;                return _rawIdByValue.TryGetValue(value, out var raw) ? raw : GetRawIdOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _rawIdByValue.TryGetValue(value, out var raw)&#10;                    ? raw&#10;                    : GetRawIdOnFail();&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Fetches a random entry from the registry.&#10;        /// Uses the provided Random instance to select an entry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;random&quot;&gt;The &lt;see cref=&quot;Random&quot;/&gt; to derive the index from.&lt;/param&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        public T GetRandom(Random random)&#10;        {&#10;            if (_frozen)&#10;            {&#10;                return _entriesByRawId.Count == 0&#10;                    ? throw new InvalidOperationException(&quot;Cannot retrieve a random entry from an empty registry.&quot;)&#10;                    : _entriesByRawId[random.Next(_entriesByRawId.Count)];&#10;            }&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.Count == 0 ?&#10;                    throw new InvalidOperationException(&#10;                        &quot;Cannot retrieve a random entry from an empty registry.&quot;)&#10;                    : _entriesByRawId[random.Next(_entriesByRawId.Count)];&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the total number of registered entries (thread-safe).&#10;        /// &lt;/summary&gt;&#10;        public int Count&#10;        {&#10;            get&#10;            {&#10;                if (_frozen) return _entriesByIdentifier.Count;&#10;                lock (_lock) return _entriesByIdentifier.Count;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts the registry's entries to a list of content.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;A list of all content stored in the registry.&lt;/returns&gt;&#10;        public List&lt;T&gt; ToList()&#10;        {&#10;            if (_frozen) return _entriesByIdentifier.Values.ToList();&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.Values.ToList();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        public IEnumerator&lt;T&gt; GetEnumerator()&#10;        {&#10;            List&lt;T&gt; snapshot;&#10;            if (_frozen)&#10;            {&#10;                snapshot = _entriesByIdentifier.Values.ToList();&#10;            }&#10;            else&#10;            {&#10;                lock (_lock)&#10;                {&#10;                    snapshot = _entriesByIdentifier.Values.ToList();&#10;                }&#10;            }&#10;            return snapshot.GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        IEnumerator IEnumerable.GetEnumerator()&#10;        {&#10;            return GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback value when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback value.&lt;/returns&gt;&#10;        protected abstract T? GetValueOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback identifier when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback identifier.&lt;/returns&gt;&#10;        protected abstract Identifier? GetIdentifierOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback raw numerical ID when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback raw numerical ID.&lt;/returns&gt;&#10;        protected abstract int? GetRawIdOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Freezes the registry, preventing further modifications.&#10;        /// &lt;/summary&gt;&#10;        public void Freeze()&#10;        {&#10;            if (_frozen) return; // idempotent&#10;            lock (_lock)&#10;            {&#10;                _frozen = true;&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Interface for registries that support freezing.&#10;    /// Freezing a registry prevents any further modifications,&#10;    /// such as adding or removing entries.&#10;    /// &lt;/summary&gt;&#10;    public interface IFreezableRegistry&#10;    {&#10;        /// &lt;summary&gt;&#10;        /// Freezes the registry, preventing further modifications.&#10;        /// &lt;/summary&gt;&#10;        void Freeze();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Indicates whether the registry is frozen.&#10;        /// &lt;/summary&gt;&#10;        bool IsFrozen { get; }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;&#10;namespace Registrar.Base&#10;{&#10;    /// &lt;summary&gt;&#10;    /// I made this class for the sole purpose of having a non-generic entry point&#10;    /// for the static Register method, so you don't have to specify the type parameter T&#10;    /// when calling Register.&#10;    /// Is it petty? Yes. Do I care? Not really.&#10;    /// It just makes the API a bit cleaner to use, and brings it closer to Minecraft's&#10;    /// &lt;c&gt;Registry.register(Registry.BLOCK, id, block)&lt;/c&gt; style.&#10;    /// &lt;para&gt;&lt;/para&gt;&#10;    /// ...which is probably not a good thing to aspire to,&#10;    /// both because Minecraft was written in another language&#10;    /// and because Minecraft's code reads like a Unabomber manifesto.&#10;    /// &lt;/summary&gt;&#10;    public static class Registry&#10;    {&#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, Identifier identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, identifier, content);&#10;        }&#10;        &#10;        public static T Register&lt;T&gt;(Registry&lt;T&gt; registry, string identifier, T content) where T : class&#10;        {&#10;            return Registry&lt;T&gt;.Register(registry, Identifier.Parse(identifier), content);&#10;        }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Abstract base class for registries that map unique identifiers to content of type T.&#10;    /// Supports registration by &lt;see cref=&quot;Identifier&quot;/&gt; as well as retrieval by &lt;see cref=&quot;Identifier&quot;/&gt; &#10;    /// or raw numerical ID. Implements &lt;see cref=&quot;IEnumerable{T}&quot;/&gt;&#10;    /// to allow enumeration of stored entries.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type of content this Registry&#10;    /// instance stores. Must be a reference type.&lt;/typeparam&gt;&#10;    public abstract class Registry&lt;T&gt; : IEnumerable&lt;T&gt;, IFreezableRegistry where T : class&#10;    {&#10;        private readonly object _lock = new object();&#10;        private int _nextRawId;&#10;        private readonly Dictionary&lt;Identifier, T&gt; _entriesByIdentifier = new Dictionary&lt;Identifier, T&gt;();&#10;        private readonly Dictionary&lt;int, T&gt; _entriesByRawId = new Dictionary&lt;int, T&gt;();&#10;        // New reverse lookup dictionaries&#10;        private readonly Dictionary&lt;T, Identifier&gt; _identifierByValue; // one-to-one enforced&#10;        private readonly Dictionary&lt;T, int&gt; _rawIdByValue;&#10;&#10;        private volatile bool _frozen;&#10;&#10;        public bool IsFrozen =&gt; _frozen;&#10;&#10;        protected Registry(IEqualityComparer&lt;T&gt;? comparer = null)&#10;        {&#10;            var valueComparer = comparer ?? EqualityComparer&lt;T&gt;.Default;&#10;            _identifierByValue = new Dictionary&lt;T, Identifier&gt;(valueComparer);&#10;            _rawIdByValue = new Dictionary&lt;T, int&gt;(valueComparer);&#10;        }&#10;        /// &lt;summary&gt;&#10;        /// Registers a new entry in the registry with the specified identifier and content.&#10;        /// If the identifier already exists, the existing content is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;registry&quot;&gt;The registry instance where the entry will be registered.&lt;/param&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The unique identifier for the content.&lt;/param&gt;&#10;        /// &lt;param name=&quot;content&quot;&gt;The content to register.&lt;/param&gt;&#10;        /// &lt;returns&gt;The registered content, either newly added or already existing.&lt;/returns&gt;&#10;        protected internal static T Register(Registry&lt;T&gt; registry, Identifier identifier, T content)&#10;        {&#10;            // Fast path: prevent entering lock if already frozen and known to reject&#10;            if (registry._frozen)&#10;                throw new InvalidOperationException(&quot;Registry is already frozen&quot;);&#10;            lock (registry._lock)&#10;            {&#10;                if (registry._frozen)&#10;                    throw new InvalidOperationException(&quot;Registry is already frozen&quot;);&#10;                if (registry._entriesByIdentifier.TryGetValue(identifier, out var registeredValue))&#10;                    return registeredValue; // id already present, return existing value&#10;                // Enforce uniqueness of value -&gt; identifier&#10;                if (registry._identifierByValue.TryGetValue(content, out var existingId))&#10;                {&#10;                    // If same identifier, treat as idempotent (shouldn't happen since earlier check). If different, throw.&#10;                    return !existingId.Equals(identifier) &#10;                        ? throw new InvalidOperationException($&quot;Value already registered under identifier '{existingId}'. Duplicate registration with '{identifier}' is not allowed.&quot;) : content;&#10;                }&#10;&#10;                var rawId = registry._nextRawId;&#10;                registry._nextRawId++;&#10;&#10;                registry._entriesByIdentifier[identifier] = content;&#10;                registry._entriesByRawId[rawId] = content;&#10;                registry._identifierByValue[content] = identifier;&#10;                registry._rawIdByValue[content] = rawId;&#10;                return content;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its identifier (thread-safe).&#10;        /// If the identifier is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the identifier, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? Get(Identifier identifier)&#10;        {&#10;            if (_frozen)&#10;                return _entriesByIdentifier.TryGetValue(identifier, out var v) ? v : GetValueOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.TryGetValue(identifier, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves content from the registry by its raw numerical ID (thread-safe).&#10;        /// If the raw ID is not found, the fallback value is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID of the content to retrieve.&lt;/param&gt;&#10;        /// &lt;returns&gt;The content associated with the raw ID, or the fallback value if not found.&lt;/returns&gt;&#10;        public T? GetByRawId(int rawId)&#10;        {&#10;            if (_frozen)&#10;                return _entriesByRawId.TryGetValue(rawId, out var v) ? v : GetValueOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.TryGetValue(rawId, out var registeredValue)&#10;                    ? registeredValue&#10;                    : GetValueOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified identifier.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;identifier&quot;&gt;The identifier to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the identifier exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsId(Identifier identifier)&#10;        {&#10;            if (_frozen) return _entriesByIdentifier.ContainsKey(identifier);&#10;            lock (_lock) { return _entriesByIdentifier.ContainsKey(identifier); }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Checks if the registry contains an entry with the specified raw numerical ID.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;rawId&quot;&gt;The raw numerical ID to check for.&lt;/param&gt;&#10;        /// &lt;returns&gt;True if the raw ID exists in the registry; otherwise, false.&lt;/returns&gt;&#10;        public bool ContainsRawId(int rawId)&#10;        {&#10;            if (_frozen) return _entriesByRawId.ContainsKey(rawId);&#10;            lock (_lock) { return _entriesByRawId.ContainsKey(rawId); }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the identifier associated with the specified content.&#10;        /// If the content is not found, the fallback identifier is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The identifier associated with the content, or the fallback&#10;        /// identifier if not found.&lt;/returns&gt;&#10;        public Identifier? GetId(T value)&#10;        {&#10;            if (_frozen)&#10;                return _identifierByValue.TryGetValue(value, out var id) ? id : GetIdentifierOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _identifierByValue.TryGetValue(value, out var id)&#10;                    ? id&#10;                    : GetIdentifierOnFail();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the raw numerical ID associated with the specified content.&#10;        /// If the content is not found, the fallback raw ID is returned.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;value&quot;&gt;The content to search for.&lt;/param&gt;&#10;        /// &lt;returns&gt;The raw numerical ID associated with the content, or the fallback&#10;        /// raw ID if not found.&lt;/returns&gt;&#10;        public int? GetRawId(T value)&#10;        {&#10;            if (_frozen)&#10;                return _rawIdByValue.TryGetValue(value, out var raw) ? raw : GetRawIdOnFail();&#10;            lock (_lock)&#10;            {&#10;                return _rawIdByValue.TryGetValue(value, out var raw)&#10;                    ? raw&#10;                    : GetRawIdOnFail();&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Fetches a random entry from the registry.&#10;        /// Uses the provided Random instance to select an entry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;random&quot;&gt;The &lt;see cref=&quot;Random&quot;/&gt; to derive the index from.&lt;/param&gt;&#10;        /// &lt;returns&gt;&lt;/returns&gt;&#10;        public T GetRandom(Random random)&#10;        {&#10;            if (_frozen)&#10;            {&#10;                return _entriesByRawId.Count == 0&#10;                    ? throw new InvalidOperationException(&quot;Cannot retrieve a random entry from an empty registry.&quot;)&#10;                    : _entriesByRawId[random.Next(_entriesByRawId.Count)];&#10;            }&#10;            lock (_lock)&#10;            {&#10;                return _entriesByRawId.Count == 0 ?&#10;                    throw new InvalidOperationException(&#10;                        &quot;Cannot retrieve a random entry from an empty registry.&quot;)&#10;                    : _entriesByRawId[random.Next(_entriesByRawId.Count)];&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns the total number of registered entries (thread-safe).&#10;        /// &lt;/summary&gt;&#10;        public int Count&#10;        {&#10;            get&#10;            {&#10;                if (_frozen) return _entriesByIdentifier.Count;&#10;                lock (_lock) return _entriesByIdentifier.Count;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts the registry's entries to a list of content.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;A list of all content stored in the registry.&lt;/returns&gt;&#10;        public List&lt;T&gt; ToList()&#10;        {&#10;            if (_frozen) return _entriesByIdentifier.Values.ToList();&#10;            lock (_lock)&#10;            {&#10;                return _entriesByIdentifier.Values.ToList();&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        public IEnumerator&lt;T&gt; GetEnumerator()&#10;        {&#10;            List&lt;T&gt; snapshot;&#10;            if (_frozen)&#10;            {&#10;                snapshot = _entriesByIdentifier.Values.ToList();&#10;            }&#10;            else&#10;            {&#10;                lock (_lock)&#10;                {&#10;                    snapshot = _entriesByIdentifier.Values.ToList();&#10;                }&#10;            }&#10;            return snapshot.GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Returns an enumerator that iterates through the content in the registry.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;An enumerator for the content in the registry.&lt;/returns&gt;&#10;        IEnumerator IEnumerable.GetEnumerator()&#10;        {&#10;            return GetEnumerator();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback value when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback value.&lt;/returns&gt;&#10;        protected abstract T? GetValueOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback identifier when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback identifier.&lt;/returns&gt;&#10;        protected abstract Identifier? GetIdentifierOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Retrieves the fallback raw numerical ID when a lookup fails.&#10;        /// Must be implemented by derived classes.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;returns&gt;The fallback raw numerical ID.&lt;/returns&gt;&#10;        protected abstract int? GetRawIdOnFail();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Freezes the registry, preventing further modifications.&#10;        /// &lt;/summary&gt;&#10;        public void Freeze()&#10;        {&#10;            if (_frozen) return; // idempotent&#10;            lock (_lock)&#10;            {&#10;                _frozen = true;&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Interface for registries that support freezing.&#10;    /// Freezing a registry prevents any further modifications,&#10;    /// such as adding or removing entries.&#10;    /// &lt;/summary&gt;&#10;    public interface IFreezableRegistry&#10;    {&#10;        /// &lt;summary&gt;&#10;        /// Freezes the registry, preventing further modifications.&#10;        /// &lt;/summary&gt;&#10;        void Freeze();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Indicates whether the registry is frozen.&#10;        /// &lt;/summary&gt;&#10;        bool IsFrozen { get; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Registrar/Registrar.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Registrar/Registrar.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFrameworks&gt;net8.0; netstandard2.1&lt;/TargetFrameworks&gt;&#10;        &lt;Authors&gt;Christos Maragkos&lt;/Authors&gt;&#10;        &lt;Version&gt;1.0.2&lt;/Version&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;        &lt;PackageId&gt;Registrar&lt;/PackageId&gt;&#10;        &lt;Description&gt;Lightweight namespaced identifier + registry library with freezing, reverse lookups, and thread-safe bootstrap.&lt;/Description&gt;&#10;        &lt;RepositoryUrl&gt;https://github.com/ChristosMaragkos/Registrar&lt;/RepositoryUrl&gt;&#10;        &lt;PackageProjectUrl&gt;https://github.com/ChristosMaragkos/Registrar&lt;/PackageProjectUrl&gt;&#10;        &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;PackageTags&gt;registry;identifiers;namespaced;game;content;freezing&lt;/PackageTags&gt;&#10;        &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;&#10;        &lt;IncludeSymbols&gt;false&lt;/IncludeSymbols&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;None Include=&quot;..\README.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFrameworks&gt;net8.0; netstandard2.1&lt;/TargetFrameworks&gt;&#10;        &lt;Authors&gt;Christos Maragkos&lt;/Authors&gt;&#10;        &lt;Version&gt;1.0.2&lt;/Version&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;        &lt;PackageId&gt;Registrar&lt;/PackageId&gt;&#10;        &lt;Description&gt;Lightweight namespaced identifier + registry library with freezing, reverse lookups, and thread-safe bootstrap.&lt;/Description&gt;&#10;        &lt;RepositoryUrl&gt;https://github.com/ChristosMaragkos/Registrar&lt;/RepositoryUrl&gt;&#10;        &lt;PackageProjectUrl&gt;https://github.com/ChristosMaragkos/Registrar&lt;/PackageProjectUrl&gt;&#10;        &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;PackageTags&gt;registry;identifiers;namespaced;game;content;freezing&lt;/PackageTags&gt;&#10;        &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;&#10;        &lt;IncludeSymbols&gt;false&lt;/IncludeSymbols&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;None Include=&quot;..\README.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>